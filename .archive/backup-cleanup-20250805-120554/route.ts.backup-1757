// app/api/financial-profile/route.ts - ROBUST VERSION
import { NextRequest, NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export async function GET() {
  try {
    const userId = 'default-user';
    
    const [user, incomeRecords, expenseRecords] = await Promise.all([
      prisma.user.findFirst({ where: { id: userId } }),
      prisma.incomeRecord.findMany({ where: { userId }, orderBy: { year: 'desc' }, take: 10 }),
      prisma.expenseRecord.findMany({ where: { userId }, orderBy: { year: 'desc' }, take: 10 })
    ]);

    if (!user) {
      return NextResponse.json({ success: false, error: 'User not found' }, { status: 404 });
    }

    // Calculate totals from individual income sources
    const yearlyData = incomeRecords.map(income => {
      const expense = expenseRecords.find(e => e.year === income.year);
      const expenses = expense ? Number(expense.totalExpenses) : 0;
      const incomeAmount = Number(income.employmentIncome) + Number(income.bonusIncome) + 
                          Number(income.investmentIncome) + Number(income.businessIncome) + 
                          Number(income.otherIncome);
      const savings = incomeAmount - expenses;
      
      return {
        year: income.year,
        income: incomeAmount,
        expenses,
        savings,
        rate: incomeAmount > 0 ? (savings / incomeAmount) * 100 : 0
      };
    });

    // Use actual current year data instead of hardcoded defaults
    const currentYearData = yearlyData[0];
    const data = {
      income: currentYearData?.income || 120000,
      expenses: currentYearData?.expenses || 72000,
      srsContributions: 0, // TODO: Load from SRS table
      taxStatus: user.taxStatus,
      fiTarget: Number(user.fiGoal),
      fiYear: user.fiTargetYear,
      leanFITargetAmount: 1850000,
      firstMillionTarget: true,
      leanFITarget: true,
      fullFITarget: true
    };

    return NextResponse.json({ 
      success: true, 
      data,
      yearlyData
    });
    
  } catch (error) {
    console.error('GET Error:', error);
    return NextResponse.json({ success: false, error: 'Load failed' }, { status: 500 });
  }
}

export async function POST(request: NextRequest) {
  let requestData;
  
  try {
    // Robust body parsing with error handling
    try {
      requestData = await request.json();
    } catch (bodyError) {
      console.error('Body parsing error:', bodyError);
      return NextResponse.json({ 
        success: false, 
        error: 'Invalid request body',
        details: 'Could not parse JSON'
      }, { status: 400 });
    }

    const { data, yearlyData } = requestData;
    const userId = 'default-user';
    const currentYear = new Date().getFullYear();

    console.log('Saving data:', { data, yearlyData });

    // Validate required data
    if (!data) {
      return NextResponse.json({ 
        success: false, 
        error: 'Missing data object' 
      }, { status: 400 });
    }

    // Sequential saves with individual error handling
    try {
      // 1. Update user profile
      await prisma.user.update({
        where: { id: userId },
        data: {
          taxStatus: data.taxStatus || 'Employment Pass',
          fiGoal: data.fiTarget || 2500000,
          fiTargetYear: data.fiYear || 2032,
          lastProfileUpdate: new Date()
        }
      });
    } catch (userError) {
      console.error('User update error:', userError);
      throw new Error('Failed to update user profile');
    }

    try {
      // 2. Save current year income
      await prisma.incomeRecord.upsert({
        where: { userId_year: { userId, year: currentYear } },
        update: { employmentIncome: data.income || 0 },
        create: { userId, year: currentYear, employmentIncome: data.income || 0 }
      });
    } catch (incomeError) {
      console.error('Income record error:', incomeError);
      throw new Error('Failed to save income data');
    }

    try {
      // 3. Save current year expenses
      await prisma.expenseRecord.upsert({
        where: { userId_year: { userId, year: currentYear } },
        update: { 
          totalExpenses: data.expenses || 0,
          savingsRate: data.income > 0 ? ((data.income - data.expenses) / data.income) * 100 : 0,
          savingsAmount: (data.income || 0) - (data.expenses || 0)
        },
        create: { 
          userId, 
          year: currentYear, 
          totalExpenses: data.expenses || 0,
          savingsRate: data.income > 0 ? ((data.income - data.expenses) / data.income) * 100 : 0,
          savingsAmount: (data.income || 0) - (data.expenses || 0)
        }
      });
    } catch (expenseError) {
      console.error('Expense record error:', expenseError);
      throw new Error('Failed to save expense data');
    }

    // 4. Save historical data
    if (yearlyData?.length > 0) {
      for (const yearly of yearlyData) {
        if (yearly.year === currentYear) continue; // Skip current year
        
        try {
          await prisma.incomeRecord.upsert({
            where: { userId_year: { userId, year: yearly.year } },
            update: { employmentIncome: yearly.income || 0 },
            create: { userId, year: yearly.year, employmentIncome: yearly.income || 0 }
          });

          await prisma.expenseRecord.upsert({
            where: { userId_year: { userId, year: yearly.year } },
            update: { 
              totalExpenses: yearly.expenses || 0, 
              savingsRate: yearly.rate || 0, 
              savingsAmount: yearly.savings || 0 
            },
            create: { 
              userId, 
              year: yearly.year, 
              totalExpenses: yearly.expenses || 0, 
              savingsRate: yearly.rate || 0, 
              savingsAmount: yearly.savings || 0 
            }
          });
        } catch (yearlyError) {
          console.error(`Error saving year ${yearly.year}:`, yearlyError);
          // Continue with other years instead of failing completely
        }
      }
    }

    console.log('Save completed successfully');
    return NextResponse.json({ success: true });
    
  } catch (error) {
    console.error('POST Error:', error);
    return NextResponse.json({ 
      success: false, 
      error: `Save failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
      details: 'Database operation failed'
    }, { status: 500 });
  }
}