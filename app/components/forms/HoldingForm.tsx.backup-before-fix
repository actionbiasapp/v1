'use client';

import React, { useState, useCallback, useMemo } from 'react';
import { type CurrencyCode } from '@/app/lib/currency';
import { HoldingFormData } from '@/app/lib/types/shared';
import CurrencySelector from '../CurrencySelector';
import HoldingConfirmation, { ConfirmedHoldingData } from '../HoldingConfirmation';
import { PriceDetectionResult } from '../../lib/priceDetection';
import { WeightedAverageResult, calculateWeightedAverage, calculateUnitsFromTotal } from '../../lib/weightedAverage';

interface HoldingFormProps {
  categoryName: string;
  holdingId?: string;
  formData: HoldingFormData;
  onFormDataChange: (data: HoldingFormData) => void;
  onSubmit: (categoryName: string, holdingId?: string) => void;
  onCancel: () => void;
  loading: boolean;
}

const HoldingForm = React.memo(({ 
  categoryName, 
  holdingId, 
  formData, 
  onFormDataChange, 
  onSubmit, 
  onCancel, 
  loading 
}: HoldingFormProps) => {
  // Enhanced state for price detection and confirmation
  const [priceDetection, setPriceDetection] = useState<PriceDetectionResult | null>(null);
  const [showConfirmation, setShowConfirmation] = useState(false);
  const [weightedAverage, setWeightedAverage] = useState<WeightedAverageResult | null>(null);
  const [priceDetectionLoading, setPriceDetectionLoading] = useState(false);

  // Enhanced symbol change handler with price detection
  const handleSymbolChange = useCallback(async (e: React.ChangeEvent<HTMLInputElement>) => {
    const symbol = e.target.value.toUpperCase();
    onFormDataChange({ ...formData, symbol });
    
    // Reset price detection when symbol changes
    setPriceDetection(null);
    
    if (symbol.length >= 2) {
      setPriceDetectionLoading(true);
      try {
        const response = await fetch('/api/prices/detect', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ symbol })
        });
        
        if (response.ok) {
          const detection = await response.json();
          setPriceDetection(detection);
        }
      } catch (error) {
        console.error('Price detection failed:', error);
        setPriceDetection({
          symbol,
          supportsAutoPricing: false,
          source: 'manual',
          currency: 'USD',
          confidence: 'low',
          error: 'Detection failed'
        });
      } finally {
        setPriceDetectionLoading(false);
      }
    }
  }, [formData, onFormDataChange]);

  const handleNameChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    onFormDataChange({ ...formData, name: e.target.value });
  }, [formData, onFormDataChange]);

  const handleLocationChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    onFormDataChange({ ...formData, location: e.target.value });
  }, [formData, onFormDataChange]);

  const handleCurrencyChange = useCallback((currency: CurrencyCode) => {
    onFormDataChange({ ...formData, currency });
  }, [formData, onFormDataChange]);

  const handleAmountChange = useCallback((amount: number) => {
    onFormDataChange({ ...formData, amount });
  }, [formData, onFormDataChange]);

  // Enhanced submit handler with confirmation flow
  const handleSubmit = useCallback(async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!formData.symbol || !formData.name || !formData.amount) {
      alert('Please fill in all required fields');
      return;
    }

    // For editing existing holdings, use original flow
    if (holdingId) {
      onSubmit(categoryName, holdingId);
      return;
    }

    // For new holdings, show confirmation if we have price detection
    if (priceDetection && formData.amount > 0) {
      try {
        const currentPrice = priceDetection.currentPrice || 0;
        const calculatedUnits = currentPrice > 0 ? calculateUnitsFromTotal(formData.amount, currentPrice) : 0;
        
        // Calculate weighted average
        const avgResult = await calculateWeightedAverage(
          formData.symbol,
          calculatedUnits,
          currentPrice,
          formData.amount
        );
        
        setWeightedAverage(avgResult);
        setShowConfirmation(true);
      } catch (error) {
        console.error('Error calculating weighted average:', error);
        // Fallback to original submit
        onSubmit(categoryName);
      }
    } else {
      // No price detection available, use original flow
      onSubmit(categoryName);
    }
  }, [formData, categoryName, holdingId, onSubmit, priceDetection]);

  // Handle confirmation from dialog
  const handleConfirmation = useCallback(async (confirmedData: ConfirmedHoldingData) => {
    try {
      // Create enhanced holding data with calculated values
      const enhancedFormData = {
        ...formData,
        // Store the confirmed values for the backend
        _confirmedQuantity: confirmedData.quantity,
        _confirmedUnitPrice: confirmedData.unitPrice,
        _confirmedTotalCost: confirmedData.totalCost,
        _enableAutoPricing: confirmedData.enableAutoPricing,
        _priceSource: priceDetection?.source || 'manual'
      };

      // Update form data to include confirmed values
      onFormDataChange(enhancedFormData);
      
      // Proceed with normal submit
      onSubmit(categoryName);
      
      // Reset confirmation state
      setShowConfirmation(false);
      setWeightedAverage(null);
    } catch (error) {
      console.error('Error during confirmation:', error);
      alert('Failed to save holding. Please try again.');
    }
  }, [formData, onFormDataChange, onSubmit, categoryName, priceDetection]);

  const handleCancelConfirmation = useCallback(() => {
    setShowConfirmation(false);
    setWeightedAverage(null);
  }, []);

  // Memoized styles
  const containerStyle = useMemo(() => ({
    overflow: 'visible' as const,
    position: 'static' as const,
    isolation: 'isolate' as const
  }), []);

  const gridStyle = useMemo(() => ({
    overflow: 'visible' as const,
    contain: 'none' as const
  }), []);

  const inputStyle = useMemo(() => ({
    position: 'relative' as const,
    zIndex: 10
  }), []);

  // Show confirmation dialog if needed
  if (showConfirmation && priceDetection && weightedAverage) {
    return (
      <div style={containerStyle}>
        <HoldingConfirmation
          symbol={formData.symbol}
          name={formData.name}
          totalAmount={formData.amount}
          currency={formData.currency}
          priceDetection={priceDetection}
          weightedAverage={weightedAverage}
          onConfirm={handleConfirmation}
          onEdit={handleCancelConfirmation}
          onCancel={handleCancelConfirmation}
        />
      </div>
    );
  }

  return (
    <div 
      className="bg-slate-800 rounded-lg p-4 border border-slate-600 mb-4"
      style={containerStyle}
    >
      <h4 className="text-white font-medium mb-3">
        {holdingId ? 'Edit Holding' : `Add to ${categoryName}`}
      </h4>
      
      <form onSubmit={handleSubmit}>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-3 mb-4" style={gridStyle}>
          <div style={inputStyle}>
            <input
              type="text"
              placeholder="Symbol (e.g., AAPL)"
              value={formData.symbol}
              onChange={handleSymbolChange}
              className="w-full bg-slate-700 text-white border border-slate-600 rounded px-3 py-2 text-sm"
              autoComplete="off"
              disabled={loading}
            />
            {/* Price detection indicator */}
            {priceDetectionLoading && (
              <div className="text-xs text-blue-400 mt-1">üîç Checking pricing...</div>
            )}
            {priceDetection && !priceDetectionLoading && (
              <div className="text-xs mt-1">
                {priceDetection.supportsAutoPricing ? (
                  <span className="text-green-400">
                    üü¢ Auto-pricing: ${priceDetection.currentPrice?.toFixed(2)} ({priceDetection.source.toUpperCase()})
                  </span>
                ) : (
                  <span className="text-amber-400">
                    üîÑ Manual pricing required
                  </span>
                )}
              </div>
            )}
          </div>
          
          <input
            type="text"
            placeholder="Company Name"
            value={formData.name}
            onChange={handleNameChange}
            className="bg-slate-700 text-white border border-slate-600 rounded px-3 py-2 text-sm"
            autoComplete="off"
            style={inputStyle}
            disabled={loading}
          />
          
          <div style={inputStyle}>
            <CurrencySelector
              value={formData.currency}
              onChange={handleCurrencyChange}
              amount={formData.amount}
              onAmountChange={handleAmountChange}
            />
          </div>
          
          <input
            type="text"
            placeholder="Location (e.g., IBKR)"
            value={formData.location}
            onChange={handleLocationChange}
            className="bg-slate-700 text-white border border-slate-600 rounded px-3 py-2 text-sm"
            autoComplete="off"
            style={inputStyle}
            disabled={loading}
          />
        </div>
        
        <div className="flex gap-2">
          <button
            type="submit"
            disabled={loading || !formData.symbol || !formData.name || !formData.amount}
            className="bg-emerald-600 text-white px-4 py-2 rounded text-sm font-medium hover:bg-emerald-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
          >
            {loading ? 'Saving...' : holdingId ? 'Update' : (showConfirmation ? 'Review Details' : 'Add Holding')}
          </button>
          
          <button
            type="button"
            onClick={onCancel}
            disabled={loading}
            className="bg-slate-600 text-white px-4 py-2 rounded text-sm font-medium hover:bg-slate-700 disabled:opacity-50 transition-colors"
          >
            Cancel
          </button>
        </div>
      </form>
    </div>
  );
});

HoldingForm.displayName = 'HoldingForm';

export default HoldingForm;
