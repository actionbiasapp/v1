// Using Alpha Vantage - more reliable, 25 free calls/day
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();
const ALPHA_VANTAGE_KEY = 'demo'; // Replace with free key from alphavantage.co

const ASSET_MAP = {
  'NVDA': { api: 'NVDA', source: 'alpha', fallback: 900 },
  'TSLA': { api: 'TSLA', source: 'alpha', fallback: 250 },
  'GOOGL': { api: 'GOOGL', source: 'alpha', fallback: 170 },
  'AAPL': { api: 'AAPL', source: 'alpha', fallback: 220 },
  'UNH': { api: 'UNH', source: 'alpha', fallback: 520 },
  'AMZN': { api: 'AMZN', source: 'alpha', fallback: 180 },
  'HIMS': { api: 'HIMS', source: 'alpha', fallback: 15 },
  'VUAA.L': { api: 'VUAA.LON', source: 'alpha', fallback: 85 },
  
  'ETH': { api: 'ethereum', source: 'coingecko', fallback: 3500 },
  'BTC': { api: 'bitcoin', source: 'coingecko', fallback: 65000 },
  'WBTC': { api: 'wrapped-bitcoin', source: 'coingecko', fallback: 65000 },
  'USDC': { api: 'usd-coin', source: 'coingecko', fallback: 1 }
};

export class PriceService {
  async fetchAlphaPrice(symbol: string): Promise<number> {
    try {
      const response = await fetch(`https://www.alphavantage.co/query?function=GLOBAL_QUOTE&symbol=${symbol}&apikey=${ALPHA_VANTAGE_KEY}`);
      const data = await response.json();
      if (data["Global Quote"]) return parseFloat(data["Global Quote"]["05. price"]); throw new Error("Rate limited");
    } catch (error) {
      console.error(`Alpha Vantage error for ${symbol}:`, error);
      return ASSET_MAP[symbol]?.fallback || 0;
    }
  }
  
  async fetchCryptoPrice(coinId: string): Promise<number> {
    try {
      const response = await fetch(`https://api.coingecko.com/api/v3/simple/price?ids=${coinId}&vs_currencies=usd`);
      const data = await response.json();
      return data[coinId].usd;
    } catch (error) {
      return ASSET_MAP[Object.keys(ASSET_MAP).find(k => ASSET_MAP[k].api === coinId)]?.fallback || 0;
    }
  }
  
  async updateAllPrices(): Promise<{ success: boolean; updated: number; errors: string[] }> {
    const holdings = await prisma.holdings.findMany({
      where: { symbol: { in: Object.keys(ASSET_MAP) } }
    });
    
    let updated = 0;
    const errors: string[] = [];
    
    for (const holding of holdings) {
      const asset = ASSET_MAP[holding.symbol];
      if (!asset) continue;
      
      try {
        let price: number;
        
        if (asset.source === 'alpha') {
          price = await this.fetchAlphaPrice(asset.api);
          await new Promise(resolve => setTimeout(resolve, 20000)); // 4 calls/minute limit
        } else {
          price = await this.fetchCryptoPrice(asset.api);
          await new Promise(resolve => setTimeout(resolve, 1200));
        }
        
        await prisma.holdings.update({
          where: { id: holding.id },
          data: {
            currentUnitPrice: price,
            priceUpdated: new Date(),
            priceSource: asset.source,
            ...(holding.unitPrice === null && { unitPrice: price })
          }
        });
        
        console.log(`âœ… ${holding.symbol}: $${price}`);
        updated++;
        
      } catch (error) {
        errors.push(`${holding.symbol}: ${error}`);
      }
    }
    
    return { success: true, updated, errors };
  }
}

export const priceService = new PriceService();
