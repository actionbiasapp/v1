export interface PriceDetectionResult {
  symbol: string;
  supportsAutoPricing: boolean;
  source: 'fmp' | 'coingecko' | 'manual';
  currentPrice?: number;
  currency: string;
  confidence: 'high' | 'medium' | 'low';
  error?: string;
}

export class PriceDetectionService {
  private readonly FMP_API_KEY = '9ERUMtxQIBjyPwr5hTMVKSG9irnMBdin';
  private readonly FMP_BASE_URL = 'https://financialmodelingprep.com/api/v3';

  async detectPriceSource(symbol: string): Promise<PriceDetectionResult> {
    const cleanSymbol = symbol.toUpperCase().trim();
    
    // Crypto detection
    if (['BTC', 'ETH', 'WBTC', 'USDC'].includes(cleanSymbol)) {
      try {
        const price = await this.fetchCryptoPrice(cleanSymbol);
        return {
          symbol: cleanSymbol,
          supportsAutoPricing: true,
          source: 'coingecko',
          currentPrice: price,
          currency: 'USD',
          confidence: 'high'
        };
      } catch (error) {
        return this.manualFallback(cleanSymbol, `Crypto API failed: ${error.message}`);
      }
    }
    
    // FMP stocks detection
    try {
      const price = await this.fetchFMPPrice(cleanSymbol);
      if (price && price > 0) {
        return {
          symbol: cleanSymbol,
          supportsAutoPricing: true,
          source: 'fmp',
          currentPrice: price,
          currency: 'USD',
          confidence: 'high'
        };
      }
    } catch (error) {
      console.log(`FMP failed for ${cleanSymbol}: ${error.message}`);
    }
    
    // Manual fallback
    return this.manualFallback(cleanSymbol, 'No API support available');
  }

  private async fetchFMPPrice(symbol: string): Promise<number | null> {
    const response = await fetch(`${this.FMP_BASE_URL}/quote-short/${symbol}?apikey=${this.FMP_API_KEY}`);
    if (!response.ok) throw new Error(`FMP API error: ${response.status}`);
    const data = await response.json();
    return data[0]?.price || null;
  }

  private async fetchCryptoPrice(symbol: string): Promise<number | null> {
    const coinMap = { 'BTC': 'bitcoin', 'ETH': 'ethereum', 'WBTC': 'wrapped-bitcoin', 'USDC': 'usd-coin' };
    const coinId = coinMap[symbol];
    if (!coinId) throw new Error('Unsupported crypto symbol');

    const response = await fetch(`https://api.coingecko.com/api/v3/simple/price?ids=${coinId}&vs_currencies=usd`);
    if (!response.ok) throw new Error(`CoinGecko API error: ${response.status}`);
    const data = await response.json();
    return data[coinId]?.usd || null;
  }

  private manualFallback(symbol: string, error: string): PriceDetectionResult {
    return {
      symbol,
      supportsAutoPricing: false,
      source: 'manual',
      currency: 'USD',
      confidence: 'low',
      error
    };
  }
}
